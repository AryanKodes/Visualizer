<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core | Neural Liquid</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; cursor: none; }
        #ui { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; background: #000;
        }
        .btn { 
            padding: 20px 80px; border: 2px solid #00FF00; background: none; 
            color: #00FF00; cursor: pointer; text-transform: uppercase; 
            font-family: 'Courier New', monospace; font-size: 30px; letter-spacing: 12px; 
            box-shadow: 0 0 20px rgba(0,255,0,0.3); transition: 0.3s;
        }
        .btn:hover { background: #00FF00; color: #000; box-shadow: 0 0 50px #00FF00; }
    </style>
</head>
<body>
    <div id="ui">
        <input type="file" id="loader" style="display:none">
        <label for="loader" class="btn">CYBER LINEN</label>
    </div>
    <audio id="audio-element" crossorigin="anonymous"></audio>

    <script>
        let audioCtx, analyzer, dataArray, source;
        let isPlaying = false;
        let sBass = 0, sMid = 0, sHigh = 0;
        let flowPos = 0;
        let particles = [];
        let stars = [];

        const audioEl = document.getElementById('audio-element');
        const loader = document.getElementById('loader');

        loader.onchange = function() {
            audioEl.src = URL.createObjectURL(this.files[0]);
            document.getElementById('ui').style.opacity = '0';
            setTimeout(() => document.getElementById('ui').style.display = 'none', 1500);
            initAudio();
        };

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyzer = audioCtx.createAnalyser();
            analyzer.fftSize = 512;
            source = audioCtx.createMediaElementSource(audioEl);
            source.connect(analyzer);
            analyzer.connect(audioCtx.destination);
            dataArray = new Uint8Array(analyzer.frequencyBinCount);
            audioEl.play();
            isPlaying = true;
            
            // Background Starfield Setup
            for(let i=0; i<60; i++) {
                stars.push({
                    x: Math.random() * windowWidth,
                    y: Math.random() * windowHeight,
                    size: Math.random() * 2 + 1,
                    freqIndex: Math.floor(Math.random() * 100)
                });
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 1);
        }

        function draw() {
            if (isPlaying) {
                analyzer.getByteFrequencyData(dataArray);
                sBass = lerp(sBass, getAvg(0, 10), 0.1);
                sMid = lerp(sMid, getAvg(20, 60), 0.1);
                sHigh = lerp(sHigh, getAvg(100, 160), 0.1);
                
                background(230, 60, map(sBass, 0, 255, 1, 6), 0.2); 
                
                // 1. FILL THE SPACE: Neural Background
                drawNeuralBackground();

                flowPos += map(sMid, 0, 255, 0.01, 0.04);
                translate(0, height / 2);

                // 2. MIRROR SYSTEM
                for (let m = -1; m <= 1; m += 2) {
                    push();
                    scale(1, m);
                    drawSilk(m === -1);
                    pop();
                }
            } else {
                background(0);
            }
        }

        function drawNeuralBackground() {
            for (let s of stars) {
                let val = dataArray[s.freqIndex];
                let pulse = map(val, 0, 255, 0, 5);
                
                // Drift stars slowly
                s.x = (s.x + 0.2) % width;
                
                noStroke();
                fill(200, 40, 100, map(val, 0, 255, 0.05, 0.3));
                rectMode(CENTER);
                rect(s.x, s.y, s.size + pulse, s.size + pulse);
                
                // Connecting lines (Filaments)
                if (sMid > 150) {
                    stroke(200, 30, 100, 0.05);
                    strokeWeight(0.5);
                    // Connect to a few neighboring "stars"
                    for (let j = 0; j < 5; j++) {
                        let other = stars[(stars.indexOf(s) + j) % stars.length];
                        let d = dist(s.x, s.y, other.x, other.y);
                        if (d < 150) {
                            line(s.x, s.y, other.x, other.y);
                        }
                    }
                }
            }
        }

        function drawSilk(isMirror) {
            noFill();
            for (let j = 0; j < 3; j++) {
                let hue = (195 + j * 20 + sBass * 0.05) % 360;
                stroke(hue, 80, 100, isMirror ? 0.1 : 0.4);
                strokeWeight(isMirror ? 1 : 2.5);
                beginShape();
                for (let x = -50; x <= width + 50; x += 50) {
                    let waveInput = x * 0.002 + flowPos + (j * 0.3);
                    let amp = map(sMid, 0, 255, 40, height * 0.2);
                    let freq = map(sBass, 0, 255, 0.8, 1.2);
                    let y = sin(waveInput * freq) * amp;
                    curveVertex(x, y);
                }
                endShape();
            }
        }

        function getAvg(s, e) {
            let total = 0;
            for (let i = s; i <= e; i++) total += dataArray[i];
            return total / (e - s + 1);
        }

        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
</body>
</html>